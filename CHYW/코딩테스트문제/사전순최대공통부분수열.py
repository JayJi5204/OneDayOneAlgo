"""
문제 설명:
    어떤 수열이 다른 수열의 부분 수열이라는 것은 다음을 의미한다.
        1. 해당 수열의 원소들이 다른 수열 내에서 순서대로 등장한다.
        2. 예를 들어, {1,1,5}는 {3,1,4,1,5,9}의 부분 수열이지만, {1,5,1}의 부분 수열은 아니다.
    또한, 어떤 수열이 다른 수열보다 사전 순으로 나중이라는 것은 다음을 의미한다.
        1. 두 수열중 첫 번째 수가 큰 쪽은 사전 순으로 나중이다.
        2. 두 수열의 첫 번째 수가 같다면, 첫 번째 수를 빼고 두 수열을 다시 비교했을 때 사전 순으로 나중인 쪽이 사전 순으로 나중이다.
        3. 길이가 0인 수열과 다른 수열을 비교하면, 다른 수열이 사전 순으로 나중이다.
    양의 정수로 이루어진 길이가 N인 수열 {$A_{1}$, ...,$A{_N}$}이 주어진다. 마찬가지로 양의 정수로 이루어진 길이가 M인 수열 {$B_{1}$,...,$B_{M}$}이 주어진다.

    수열 A와 수열 B가 공통으로 갖는 부분 수열들 중 사전 순으로 가장 나중인 것을 구하세요.

제한 사항:
    시간 제한 1초
    메모리 제한 1024MB
    $(1 <= N <= 100)$ 
    $A_1,A_2, ... ,A_N$ $(1 <= A_i <= 100)$
    $(1 <= M <= 100)$
    $B_1,B_2, ... ,B_M$ $(1 <= B_i <= 100)$

문제 풀이:
    1. 두 수열, 내에서 공통으로 존재하는 원소 중 가장 큰 값을 찾는다.
    2. 가장 큰 값이 여러 개라면, 가장 앞쪽에 있는 원소를 선택.
    3. 선택한 원소 이후의,부분 범위에서 1~2 과정을 반복.
    4. 공통 원소가 없으면 종료.

"""

def solution():
    An = int(input())
    A = list(map(int,input().split()))
    Bn = int(input())
    B = list(map(int,input().split()))

    result = []
    while True:
        common = set(A) & set(B)
        if not common:
            break

        max_val = max(common)

        A_idx = A.index(max_val)
        B_idx = B.index(max_val)

        result.append(max_val)

        #선택한 원소 다음 범위로 갱신
        A = A[A_idx+1:]
        B = B[B_idx+1:]
    print(len(result))
    print(*result)
    return 
if __name__=="__main__":
    solution()