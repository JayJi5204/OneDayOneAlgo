'''
문제 설명:
    비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오.

    add x: S에 x를 추가한다. (1 ≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.
    remove x: S에서 x를 제거한다. (1 ≤ x ≤ 20) S에 x가 없는 경우에는 연산을 무시한다.
    check x: S에 x가 있으면 1을, 없으면 0을 출력한다. (1 ≤ x ≤ 20)
    toggle x: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1 ≤ x ≤ 20)
    all: S를 {1, 2, ..., 20} 으로 바꾼다.
    empty: S를 공집합으로 바꾼다.

문제 풀이:
    처음 접근 했을 때는 단순히 set()을 사용하여 요구사항을 구현하였다.
    하지만 결과는 시간초과

    시간 복잡도를 더 줄이려면, 비트마스킹(Bitmasking) 활용해야한다.
    이 문제는 숫자의 범위가 1부터 20까지로 매우 작다. 
    이럴 때는 set 자료형보다 비트마스킹을 사용하는 것이 훨씬 효율적이다. 
    20개의 비트(0 또는 1)만 있으면 각 숫자가 있는지 없는지 표현할 수 있기 때문이다.

구현 방법:
    Add (비트 켜기: | OR 연산)
        - s |= (1 << x)1 << x: $x$번째 자리에만 1이 있고 나머지는 0인 숫자를 만듭니다.
        - | 연산: 기존 집합에 해당 자리가 0이면 1로 바꾸고, 이미 1이면 그대로 둡니다.
    Remove (비트 끄기: & ~ AND NOT 연산)
        - s &= ~(1 << x)~(1 << x): $x$번째 자리만 0이고 나머지는 모두 1인 숫자를 만듭니다.
        - & 연산: $x$번째 자리만 강제로 0으로 만들고, 나머지는 기존 상태를 유지합니다.
        - Check (비트 확인: & AND 연산)s & (1 << x)결과가 0이면 해당 자리에 1이 없는 것(False)이고, 0이 아니면 1이 있는 것(True)입니다.
    Toggle (비트 반전: ^ XOR 연산)
        - s ^= (1 << x)^ 연산: 두 비트가 다르면 1, 같으면 0을 반환합니다. 
        - 즉, 있으면 0으로(제거), 없으면 1로(추가) 바꿉니다.
    All (모두 1로 만들기)
        - s = (1 << 21) - 1이진수 1000000000000000000000 (21번째 자리만 1)에서 1을 빼면, 그 아래 비트들이 모두 1인 11111111111111111111이 됩니다.(1부터 20까지 모두 포함)
'''

import sys

input = sys.stdin.readline

def solution():
    m = int(input())
    # 20개의 숫자를 비트로 표현 (0으로 초기화)
    # n번째 비트가 1이면 숫자 n이 집합에 포함된 것
    s = 0

    for _ in range(m):
        command = input().split()
        
        op = command[0]
        
        if op == "all":
            s = (1 << 21) - 1  # 1부터 20까지 모든 비트를 1로
        elif op == "empty":
            s = 0
        else:
            x = int(command[1])
            if op == "add":
                s |= (1 << x)
            elif op == "remove":
                s &= ~(1 << x)
            elif op == "check":
                # x번째 비트가 켜져 있는지 확인
                print(1 if s & (1 << x) else 0)
            elif op == "toggle":
                s ^= (1 << x)

if __name__ == "__main__":
    solution()