'''
문제 설명:
    N면체 주사위의 각 면에 적힌 수가 주어졌을 때, 
    주사위를 굴렸을 때 각 면이 나올 확률이 모두 같다면 주사위를 굴렸을 때 나오게 되는 수의 기댓값은 과연 몇일까?

    두 변수 X,Y에 대한 기댓값 E(X + Y) = E(X) + E(Y)가 성립하므로 이 문제에 대한 답을 아래와 같이 간단하게 나타낼 수 있다.

    N_i = i번 째 N면체 주사위 
    S_i = 모든 면적에 적힌 수를 더한 값
    
    S_1/N_1 + S_2/N_2 + ... + S_M/N_M

    즉, 각 주사위에서 나오게 되는 수의 기댓값을 모두 더하면 답이 되는 것이다. 이 답을 정확하게 출력하기 위해, 모든 분수를 통분한다고 생각해보자. 
    이 분수의 분모와 분자의 값이 어떤 범위까지 치솟게 될 것인가? 즉 분모와 분자를 모두 저장하고 있게 되면, 
    두 분수의 합을 구할 때 분모와 분자를 적정한 범위 내에서 계산해낼 수 없다는 문제에 부딪히게 된다.
    "그렇다면 분모와 분자를 어떤 모듈러 상에서 가지고 있으면 되지 않을까?"라고 생각할 수 있지만, 그러면 분모와 분자를 약분할 수가 없게 된다. 그렇기에, 분수를 다음과 같이 모듈러 상에서 하나의 정수로 가지고 있는 방법을 채택하게 되었다.

    어떤 분수가 기약분수로 나타냈을 때 a/b이면, 이 분수는 a x b^-1 mod X(X는 소수)로 대신 계산하도록 한다.
    여기서 b^-1은 b의 모듈러 곱셈에 대한 역원이다.

    b의 모듈러 곱셈에 대한 역원 b^-1은 다음과 같은 성질을 만족하는 정수이다.
        - b^-1 * b = 1 (mod X)
    소수 모듈러에서만 성립하는 페르마의 소정리에 의해 b^(X-1) = 1(mod X)가 성립하기에, b^-1(mod X) 역시 성립함을 알 수 있다.

    b^-1 * b = 1 (mod X)
    b^(x-1) = 1 (mod X) 
    b^(x-2) = b^-1 (mod x)

    예를 들어,X=11, Q = 7 / 3이라고 가정해보자,
    이 때, 페르마의 소정리에 의해 3^-1 = 4 mod 11이다.
    따라서 Q = 7 x 4 = 28 mod 11 = 6 이며, Q*3 mod 11 = 7 이다.

    분수를 이와 같은 방식으로 나타낸다면, 두 분수의 덧셈, 뺄셈, 곱셈은 mod X에서 두 정수를 가지고 계산하듯이 처리하고, 나눗셈은 나누는 분수의 곱셈에 대한 역원을 구한 후 그 역원을 mod X에서 곱하는 것으로 처리한다면, 분수를 정확히 출력하기 위해 통분을 하거나 기약분수로 만드는 골치아픈 일을 할 필요가 없어진다.
    이 방법에도 문제가 있는 것은 마찬가지이다. 앞의 예에서 7/3을 6으로 저장했지만, 그냥 6/1도 6으로 저장할 것이다.
    즉 서로 다른 두 분수도 모듈러 상에서 같은 정수로 저장하여, 정확한 판별을 한다는 우리의 목적에 부합하지 않는 것이다.
    또 다른 문제로는, 분모가 소인수로 X를 가질 때에는 역원을 계산할 수 없어서 모듈러로 나타낼 수가 없다는 점이 있다.
    이러한 문제를 해결하기 위해 모듈러를 1,000,000,007와 같은 큰 소수로 하는데, 
    이를 통해 서로 다른 두 분수가 같은 정수로 타나나게 되는 확률을 낮추고, 분모가 가질 수 있는 소인수의 범위를 늘리는 효과를 볼 수 있다.

    이 방식으로 M개의 주사위가 있고, i번 째 주사위가 N_i면체 주사위이며, 모든 면에 적힌 숫자를 더한 값이 S_i일 때, 각 주사위에 대해서 주사위를 던졌을 때 주사위의 각 면이 나올 확률이 동일하다면, 모든 주사위를 한번씩 던졌을 때 나온 숫자들의 합의 기댓값을 구하는 문제를 해결해보자.
    답을 기양분수로 나타내었을 때 a/b가 된다면, (a x b^-1) mod 1,000,000,007을 대신 출력하도록한다.

제한 사항:
    시간 제한 1초
    메모리 제한 512MB
    주사위 개수 M(1 ≤ M ≤ 104)
    주사위 면 N(1 ≤ N ≤ 109)
    주사위 합 S(1 ≤ S ≤ 109)
    mod X = 1,000,000,007

문제 풀이:
    먼저 문제에서 설명한 계산 방법을 그대로 따라가 보자
        1. b^(X-2) = b^-1 계산
        2. a x (b^-1) 계산
        3. a x (b^-1) % X 계산
    
    계산이 끝난 순간 답이 된다.
    하지만 제일 중요한것은 거듭제곱의 수가 1,000,000,007이라는 것이다.
    따라서 분할 정복을 통해 시간 복잡도를 log n으로 줄이기만하면 답은 쉽게 구해낼 수 있다.

    2^10 = 2^5 * 2^5
    2^5 = 2^2 * 2^2 * 2^1
    2^2 = 2^1 * 2^1
    2^1 = 2

    분할 정복을 통해 구해지는 점화식 구하면 아래와 같다.
    a^b = a^(b//2) * a^(b//2)

    주사위는 하나가 아닌 여러개 이고 E(X+Y) = E(X) + E(Y)가 성립하므로,
    각 주사위의 기댓값을 더해주면 된다.
'''

def power(a,b,mod):
    
    if b == 1:
        return a
    
    temp = power(a,b//2,mod)
    
    if b%2 == 0:
        return (temp*temp)%mod
    else:
        return (temp*temp*a)%mod

def solution(mod):
    '''
        1. b^(X-2) = b^-1 계산
        2. a x (b^-1) 계산
        3. a x (b^-1) % X 계산
        4. 각 주사위에 대한 기댓값을 모두 더한다.
    '''
    answer = 0
    m = int(input())  

    for i in range(m):
        n,s = list(map(int,input().split()))
        answer = (answer + s * power(n,mod-2,mod) % mod)%mod
    return answer

if __name__=="__main__":
    mod=1000000007
    print(solution(mod))