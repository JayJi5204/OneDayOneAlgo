'''
우선순위 디스크 컨트롤러를 구현하는 문제

문제 설명:
1. 어떤 작업 요청이 들어왔을 때 작업의 번호, 작업의 요청 시각, 작업의 소요 시간을 저장해 두는 대기 큐가 있습니다. 처음에 이 큐는 비어있습니다.
2. 디스크 컨트롤러는 하드디스크가 작업을 하고 있지 않고 대기 큐가 비어있지 않다면,
   가장 우선순위가 높은 작업을 대기 큐에서 꺼내서 하드디스크에 그 작업을 시킵니다. 
   이때, 작업의 소요시간이 짧은 것, 작업의 요청 시각이 빠른 것, 작업의 번호가 작은 것 순으로 우선순위가 높습니다.
3. 하드디스크는 작업을 한 번 시작하면 작업을 마칠 때까지 그 작업만 수행합니다.
4. 하드디스크가 어떤 작업을 마치는 시점과 다른 작업 요청이 들어오는 시점이 겹친다면 하드디스크가 작업을 마치자마자 디스크 컨트롤러는 요청이 들어온 작업을 대기 큐에 저장한 뒤 우선순위가 높은 작업을 대기 큐에서 꺼내서 하드디스크에 그 작업을 시킵니다. 또, 하드디스크가 어떤 작업을 마치는 시점에 다른 작업이 들어오지 않더라도 그 작업을 마치자마자 또 다른 작업을 시작할 수 있습니다. 이 과정에서 걸리는 시간은 없다고 가정합니다.

나의 아이디어:
처음에는 단순히 작업 소요시간, 작업 요청 시간이 짧은 것들을 꺼낸 후 반환 시간을 리턴해야한다고 생각했다.
하지만 결과는 실패

놓쳤던 부분은 시점이었으며 시점마다 할 수 있는 작업이 다르다는 것이다.
다시 말하면, 요청 시각 3초인 작업은 1초에서 작업할 수 없다는 점이다.

그래서 작업이 끝난 시점이 3초라면 그 다음에 작업 할 수 있는 것은 요청 시간이 3초 아래인 것들이다.

따라서 아래와 같이 구현할 수 있다.
1. 시점에 따라 작업할 수 있는 것들을 heap에 저장한다.
2. heap에 작업이 존재한다면 꺼내어 "현재시점 - 요청" 시간을 계산한다.

'''

import heapq

def solution(jobs):
    answer = 0
    time = 0
    finished = 0
    heap = []
    before_req = -1
    
    while finished < len(jobs):
        #현재 시간 기준 작업할 수 있는 애들 가져오기
        for job in jobs:
            if before_req < job[0] <= time:
                heapq.heappush(heap,[job[1],job[0]])
        if len(heap)>0:
            run,req_t = heapq.heappop(heap)
            before_req = time
            time += run
            answer += (time - req_t)
            finished += 1
        else:
            time+=1
            
    return int(answer/len(jobs))