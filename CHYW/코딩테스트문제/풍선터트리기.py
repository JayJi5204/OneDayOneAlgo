'''
일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 

규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return

다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.

1. 임의의 인접한 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.
2. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.
3. 인접한 두 풍선 중에서 번호가 더 작은 풍선을 터트리는 행위는 최대 1번
4. 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

제한사항:
    1. a의 길이는 1 이상 1,000,000 이하입니다.
    2. a[i]는 i+1 번째 풍선에 써진 숫자를 의미합니다.
    3. a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
    4. a의 모든 수는 서로 다릅니다.

문제 풀이:
    인접한 풍선 두 개를 선택하고 큰 것들을 모두 지웠을 때,
    타겟 풍선의 양 옆에 풍선들의 번호가 타겟 풍선 보다 작으면 안됨
    
    예를 들어 [-16,27,65,-2,58,-92,-71,-68,-61,-33] 가 주어졌을 때,
    타겟 풍선이 -92라고 가정하면, 가장 작은 수이기 때문에 양 옆에 어떠한 수가 와도 살아남을 수 있음
    이 말은 가장 작은 수는 무조건 살아남는다는 뜻임.

    예를 들어 타겟 풍선이 27이라고 가정하면 타겟 풍선의 오른쪽에 마지막으로 살아남는 풍선은 -92라는 말이 된다.
    그리고 타겟 풍선의 왼쪽에 마지막으로 살아남는 수 또한 가장 작은 수인 -16이 된다.

    결국 타겟 풍선 27의 양 옆에 있는 수는 -16 -92가 된다는 뜻이다.
    또한 조건에 따라, 타겟 풍선 보다 작은 풍선을 터트리는 행위는 최대 1번이기 때문에,
    타겟 풍선의 양 옆에 있는 수가 타겟 풍선 보다 작으면 살아남을 수 없다는 뜻이다.

    따라서 아래와 같이 구현할 수 있다.
    1. 타겟 풍선의 왼쪽에 있는 수의 최솟값을 구한다.
    2. 타겟 풍선의 오른쪽에 있는 수의 최솟값을 구한다.
    3. 타겟 풍선의 양 옆에 있는 수가 타겟 풍선 보다 작으면 continue
    4. 그렇지 않으면 answer += 1

    제한 사항에서 주어진 n의 최대값이 1,000,000이기 때문에 O(n)으로 구현해야 시간 초과가 나지 않는다.
    dp를 이용하여 왼쪽에서부터 최솟값, 오른쪽에서부터 최솟값을 구하면, 각 인데스 마다의 양 옆의 최솟값을 O(1)로 구할 수 있다.

    그리고 단순 대소 비교로 answer를 구할 수 있기 때문에 전체 시간 복잡도는 O(n)이 된다.



'''
def solution(a):
    answer = 0
    
    dp1 = [0]*len(a)
    dp2 = [0]*len(a)
    
    dp1[0] = a[0]
    dp2[-1] = a[-1]
    
    for i in range(1,len(a)):
        dp1[i] = min(a[i],dp1[i-1])
        
    for i in range(len(a)-2,-1,-1):
        dp2[i] = min(a[i],dp2[i+1])
    
    for i in range(len(a)):
        if dp1[i] < a[i] and a[i] > dp2[i]: continue
        else: answer+=1
    return answer