'''
문제 설명:
    1.각 사원마다 근무 태도 점수와 동료 평가 점수가 기록되어 있다.
    2.어떤 사원이 다른 임의의 사원보다 두 점수가 모두 낮은 경우가 한 번이라도 있다면 그 사원은 인센티브를 받지 못한다.
    3. 그렇지 않은 사원들에 대해서는 두 점수의 합이 높은 순으로 석차를 내어 석차에 따라 인센티브가 차등 지급한다.
    4. 두 점수의 합이 동일한 사원들은 동석차이며, 동석차의 수만큼 다음 석차는 건너 뜁니다. 
    5.  예를 들어 점수의 합이 가장 큰 사원이 2명이라면 1등이 2명이고 2등 없이 다음 석차는 3등부터이다.
    
제한 사항:
    1. 1 ≤ scores의 길이 ≤ 100,000
    2. scores의 각 행은 한 사원의 근무 태도 점수와 동료 평가 점수를 나타내며 [a, b] 형태이다.
    3. scores[0]은 완호의 점수이다.
    4. 0 ≤ a, b ≤ 100,000

문제 풀이:
    이 문제의 핵심은 "나보다 두 점수가 모두 높은 사람이 있는가?"를 빠르게 찾는 것이다.
    1. 근무 태도를 기준으로 정렬한다.
    2. 만약 근무 태도 점수가 같다면, 동료 평가 점수를 기준으로 오름차순으로 정렬한다.
    3. 이렇게 정렬하면, 뒤에 오는 사람은 무조건 앞사람보다 1번 점수가 낮거나 같다.
    4. 현재 사람의 동료 평가 점수가 그 최대값 보다 작다면, 이 사람은 무조건 근무 태도 점수와 동료 평가 점수 모두가 자기보다 높은 누군가가 존재한다는 뜻이므로 탈락이다.
    5. 다시 말하면 동료 평가 점수의 최대값을 찾는 이유는, 인센티브를 못받는 사람을 석차에 포함시키지 않겠다는 의미가된다.

'''
import heapq

def solution(scores):
    answer = 0
    
    target = scores[0]
    target_sum = sum(target)
    
    scores.sort(key=lambda x: (-x[0],x[1]))

    max_b = 0
    answer = 1
    
    for a,b in scores:
        if a > target[0] and b > target[1]:
            return -1
        
        if b >= max_b:
            max_b = b
            if a+b > target_sum:
                answer+=1
    
    return answer