"""
문제 설명:
    자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 리턴

제한 사항:
    0< A,B,C < 2,147,483,647(약 21억)
    0.5초(50000000 연산)

문제 풀이:
    요구 사항을 가장 간단하게 표현하면 (A**B)%C로 나타낼 수 있다.
    하지만 수가 커질 경우 엄청난 연산량을 요구한다.

    단순하게 계산할 경우 시간복잡도는 O(n^2) 최악의 경우 20억^20억

    로그를 취하여 곱연산을 더하기 연산으로 바꾼다면 굉장히 쉬워질것 같다.

    A = 10 , B = 20억
    
    10 * 10 ... * 10 = 10 ** 21억 <- 밑이 10인 로그 함수 (역연산)
    10 + 10 ... + 10 = 10 * 21억 <- 지수 함수(역연산)

    A = 123 , B = 20억

    123 * 123 ... * 123 = 123**20억 <- 밑이 123인 로그(역연산)
    log(123 + 123 ... + 123) = 123 * 20억 <- 지수 함수(역연산)

    -----------------------------------------------------------

    위의 풀이는 수학적으로 맞는말이지만, 지금 이 문제에는 적용할 수 없다.
    왜냐하면 값으로 정수가 나와야하는데, 이렇게 하면 부동소수점 계산이 나와서 모두 틀린다.

    아래의 법칙을 이용하여 분할 정복을 통해 재귀적으로 문제를 풀어야한다.

    지수 법칙
        A^m+n = A^m x A^n

    나머지 분배 법칙
        (AxB)%C = (A%C) *(B%C) % C 

    분할 정복의 원리지수 법칙에 따라 다음과 같이 계산을 절반씩 나눌 수 있다:
        1. $B$가 짝수일 때: $A^B = A^{B/2} \times A^{B/2}$$B$가 
        2. 홀수일 때: $A^B = A^{B/2} \times A^{B/2} \times A$
    
    이렇게 풀이할 경우 시간 복잡도를 log(B)로 획기적으로 줄일 수 있다.
"""

def power(a,b,c):
    if b == 1:
        return a%c
    
    temp = power(a,b//2,c)

    if b%2 == 0:
        return (temp * temp) % c
    else:
        return (temp*temp*a) % c

def solution(A,B,C):
    return power(A,B,C)

if __name__=="__main__":
    A,B,C = list(map(int,input().split()))
    print(solution(A,B,C))
