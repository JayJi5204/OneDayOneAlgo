"""
문제 설명:
    상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.
    상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.
    
    모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 리턴 

    즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.
    [
        [50, 10, 100, 20, 40],
        [30, 50, 70, 10, 60],
    ],
    [
        [30, 50, 70, 10, 60],
        [50, 10, 100, 20, 40],
    ]
    위의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.

제한 사항:
    n (1 ≤ n ≤ 100,000)
    시간제한 1 초

문제 풀이:
    일반적으로 완전 탐색을 진행하면 최대값을 구할 수 있다.
    하지만 O(n^2)으로 풀이할 경우 시간복잡도는 100억으로 시간초과가 난다.

    DP로 접근하여 최대한 연산량을 줄여야한다.
    각 인덱스를 탐색하며 스티커를 뗄지 안뗄지를 결정한다.

    고려해야할 방향은 위,아래,오른쪽,왼쪽 이므로 4방향에 대한 조건을 고려한다.

    맨 위 인덱스 탐사
    1. 아래,왼쪽으로 -1칸 인덱스의 값과, 현재 인덱스 값을 포함한 값이 최댓값일 경우 뜯는다.
    2. 왼쪽으로 -1칸 인덱스의 값이, 최댓값일 경우 뜯지 않는다.

    맨 아래 인덱스 탐사
    1. 위,왼쪽으로 -1칸 인덱스의 값과, 현재 인덱스 값을 포함한 값이 최댓값일 경우 뜯는다.
    2. 왼쪽으로 -1칸 인덱스의 값이, 최댓값일 경우 뜯지 않는다.

    왼쪽으로 -1칸 까지의 최적의 값과 위 또는 아래, 왼쪽 -1칸 값 + 현재 값 중 가장 큰 값을 찾으면 된다.

    따라서 점화식은 아래와 같다.
        dp[0][i] = max(dp[0][i-1], dp[1][i-1] + dp[0][i])
        dp[1][i] = max(dp[1][i-1], dp[0][i-1] + dp[1][i])
"""

from typing import List 

def solution(n:int,stickers:List[List[int]]):

    dp = [[0]*(n) for _ in range(2)]
    dp[0][0]=stickers[0][0]
    dp[1][0]=stickers[1][0]

    for i in range(1,n):
        dp[0][i] = max(dp[0][i-1], dp[1][i-1] + stickers[0][i])
        dp[1][i] = max(dp[1][i-1], dp[0][i-1] + stickers[1][i])

    return max(dp[0][-1],dp[1][-1])

if __name__=="__main__":
    T = int(input())
    for _ in range(T):
        n = int(input())
        stickers = []
        for _ in range(2):
            stickers.append(list(map(int,input().split())))
        print(solution(n,stickers))